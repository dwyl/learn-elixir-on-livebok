# A few things on Finite Automata with Elixir/Erlang

```elixir
Mix.install([
  {:machinery, "~> 1.0.0"},
  {:gen_state_machine, "~> 3.0"},
  {:states_language, "~> 0.2.3"},
  {:xstate, "~> 0.1.0"},
  {:jason, "~> 1.4"}
])
```

## Introduction

State machines or State Automata are designed to recognize patterns in general (cf [Wikipedia](https://en.wikipedia.org/wiki/Finite-state_machine)). The process takes a finite set of states, and describes the possible transitions, the change of state in response to some inputs.

Our machine `M` is represented as: `(states, inputs, transition_function, init_state, final_admissible_states)`:

<!-- livebook:{"force_markdown":true} -->

```elixir
M = [Q: {:opened, :unlocked, :locked, :trapped}, S: (:open, :close, lock, :unlock),t,:locked, Q]

t: Q x S -> Q
```

where the transition function `t` is defined by a mapping $t(q_i, s_j) = q_k$. These actions have typically side-effects.

This formalism can be interresting to use when your process graph is not only a sequential series of events, but has some cycles, branches or timeouts.

Erlang has an in-build solution `:gen_statem`.

Some blogs and documentation:

* [GenStateMachine timeouts](https://dockyard.com/blog/2020/01/31/state-timeouts-with-gen_statem)
* [Struct implementation](https://blog.appsignal.com/2020/07/14/building-state-machines-in-elixir-with-ecto.html)
* [Ecto and building state machines](https://blog.appsignal.com/2020/07/14/building-state-machines-in-elixir-with-ecto.html)
* [about State Machines](https://www.freecodecamp.org/news/state-machines-basics-of-computer-science-d42855debc66/)
* the libraries: [Xstate](https://hexdocs.pm/xstate/Xstate.html), [Machinery](), [GenStateMachine](https://hexdocs.pm/gen_state_machine/GenStateMachine.html), [:gen_statem](https://www.erlang.org/doc/man/gen_statem.html)
* A [video](https://www.youtube.com/watch?v=4rNYAvsSkwk) among many.

Below are presented:

* a (simple) module based implementation of a state machine, the "door" example,
* its implementation by librabries `Xstate` and `Machinery` and `gen_statem`,
* a time based process with `GenStateMachine`, where you control when you logout an inactive user by using the "timout" action from `:gen_statem` [actions](https://www.erlang.org/doc/man/gen_statem.html#type-action),
* an NFA with a regex built with `gen_statem``

## DFA: the Door model

**DFA**: given a state and an input, there exists only one output or next state. For this reason it is said to be "deterministic". The words "input" and "event" are equivalent here.

Let's take the door example. It is a simple _deterministic_ finite one. A door can open or closed, locked or unlocked. The map of our transitions is:

<!-- livebook:{"force_markdown":true} -->

```elixir
%{
 "locked"     => "unlocked",    #<-- :unlock
  "unlocked"  => "locked",      #<-- :lock
  "unlocked"  => "opened",      #<-- :open
  "opened"    => "unlocked",    #<-- :close
  "*"         => "trap"         #<-- :dead_end
}
```

For example, when the state `:locked` receives the event `:unlock`, the state changes to `:unlocked`. Depending on your needs, you may consider that for any _other state_, the effect of the event `:unlock` is:

* whether the _identity_,
* or a _trap state_ ❌ where you raise an error.

You have several ways to represent this:

* an example of state transition diagram:

```mermaid
  stateDiagram-v2
  direction LR

  opened --> unlocked: close
  opened --> ❌: lock, unlock, open
  locked --> unlocked: unlock
  locked --> ❌: lock, open, close
  unlocked --> opened: open
  unlocked --> unlocked: unlock, close
  unlocked --> locked: lock
```

* an example of the corresponding state/event transition table:

| effect of event on state | unlocked    | locked       | opened        |
| ------------------------ | ----------- | ------------ | ------------- |
| `:unlock`                | id          | -> `unloked` | ❌           |
| `:lock`                  | -> `locked` | ❌          | ❌           |
| `:open`                  | -> `opened` | ❌          | ❌           |
| `:close`                 | id          | ❌          | -> `unlocked` |

## Struct based implementation

Since a machine is essentially a succession of state transitions, we need to manage the state. The machine will be a module and we will hold the state in a _struct_. The transition function takes this struct (current state) and an event and returns the next state:

<!-- livebook:{"force_markdown":true} -->

```elixir
 (%State{state: current}, event)  ->  %State{state: new_state}
```

Thanks to pattern matching, Elixir makes it easy to code all of the allowed transitions. For simplicity, all the effects of inputs on the states that are not listed as admissible are considered as trapped, in other words will generate an error tuple_. Although simple, this pattern can be useful.

<!-- livebook:{"break_markdown":true} -->

A transition has typically side-effects. We can add anything useful to the struct, a name, a counter... that can be changed. For example, the struct holds a counter that is incremented by 1 each time the state goes to `:opened`. We also implement an async action triggered when the state leaves hte value `:locked`.

```elixir
defmodule Door do
  @moduledoc """
  Simple implementation of a struct and pattern matching (cf "source")
  """
  require Logger
  defstruct [:name, count: 0, state: :locked]

  @doc """
  Takes a %Door{} struct with a given state, and an event, and returns
  the struct with updated state.
    iex> Door.transition_to(%Door{state: :unlocked}, :open)
    {:ok, %Door{name: nil, count: 1, state: :opened}}
  """
  def transition_to(%Door{state: :locked} = door, :unlock) do
    call_guard()
    {:ok, %Door{door | state: :unlocked}}
  end

  def transition_to(%Door{state: :unlocked} = door, :open) do
    {:ok, %Door{door | count: door.count + 1, state: :opened}}
  end

  def transition_to(%Door{state: :opened} = door, :close) do
    {:ok, %Door{door | state: :unlocked}}
  end

  def transition_to(%Door{state: :unlocked} = door, :lock) do
    {:ok, %Door{door | state: :locked}}
  end

  # all other combinations state/event are not permitted.
  def transition_to(_, _), do: {:error, :transition_to_is_not_allowed}

  @doc """
  Simulate an async call
    iex> Door.call_guard() |> Task.await()
    :ok
  """
  def call_guard do
    Task.async(fn ->
      Process.sleep(1_000)
      Logger.debug("warn the guards.....")
    end)
  end
end
```

We can test a sequence of events:

```elixir
[:unlock, :close, :open, :open, :close, :open, :close, :lock, :unlock, :open]
|> Enum.reduce(%Door{}, fn event, d ->
  case Door.transition_to(d, event) do
    {:ok, door} ->
      IO.inspect(door.state)
      %Door{d | count: door.count, state: door.state}

    {:error, _} ->
      d
  end
end)
```

## Xstate package

The formalism of [Xstate](https://github.com/natserract/xstate) is purely functional and declarative.

```elixir
# import Xstate

use Xstate.StateMachine
alias Xstate.StateMachine, as: X

func = fn msg, inside ->
  IO.puts("#{msg} in #{inside}")
  {:ok, msg}
end

machine = %X.Machine{
  initial_state: "unlocked",
  mapping: %{
    :lock => %X.Transitions{
      target: "locked",
      before: fn _ ->
        func.(:before_transition_, "unlocked")
      end,
      before: fn context -> IO.inspect(context) end,
      callback: fn _ ->
        func.(:after_transition, "locked")
      end
    },
    :unlock => %X.Transitions{
      target: "unlocked",
      before: fn _ ->
        func.(:before_transition_, "locked")
      end,
      callback: fn _ ->
        func.(:after_transition, "unlocked")
      end
    },
    :open => %X.Transitions{
      target: "open",
      before: fn _ ->
        func.(:before_transition_, "unlocked")
      end,
      callback: fn _ ->
        func.(:after_transition, "opened")
      end
    },
    :close => %X.Transitions{
      target: "unlocked",
      before: fn _ ->
        func.(:before_transition_, "opened")
      end,
      callback: fn _ ->
        func.(:after_transition, "unlocked")
      end
    }
  },
  modifiable_states: MapSet.new([""])
}
```

```elixir
machine = X.new(machine)
```

```elixir
X.transition(machine, "open") |> IO.inspect()
X.transition(machine, "close") |> IO.inspect()
X.transition(machine, "lock") |> IO.inspect()
X.get_states(machine) |> IO.inspect()
```

## Machinery package

We can use the package [Machinery](https://github.com/joaomdmoura/machinery); it is based on a struct that holds the state, and on the declation of a `transitions` map. It exposes a function `Machinery.transition_to/3` that takes the state struct, its module name, and a possible state. It returns `{:ok, new_state_struct}` or `{:error, message}` when the transition is found in the transition map or not (our "trap" state).

> Note that with Machinery, you cannot consider identity actions because you would have multiple transitions for the same state.

The struct can be an `Ecto` schema so you can get persistance into a database.

Lastly, besides being declarative, you use strings as state identifiers.

Below we display the same "deterministic" door process using the simple Machinery declarative style.

```elixir
defmodule MachineryDoor do
  use Machinery,
    field: :door,
    # The first state declared will be considered the initial state.
    states: ["locked", "opened", "unlocked"],
    transitions: %{
      "locked" => "unlocked",
      "unlocked" => ["locked", "opened"],
      "opened" => "unlocked"
    }

  require Logger

  defstruct count: 0

  def after_transition(%MachineryDoor{} = struct, "opened") do
    Map.update!(struct, :count, &(&1 + 1))
  end

  def after_transition(%MachineryDoor{} = struct, "unlocked") do
    Task.async(&async_task/0) |> Task.await()
    struct
  end

  def async_task do
    Task.async(fn ->
      Process.sleep(1_000)
      Logger.debug("warn the guard____")
    end)
  end
end
```

```elixir
require Logger

[
  "unlocked",
  "locked",
  "opened",
  "unlocked",
  "opened",
  "unlocked",
  "locked",
  "unlocked",
  "opened"
]
|> Enum.reduce(%MachineryDoor{}, fn state, struct ->
  case Machinery.transition_to(struct, MachineryDoor, state) do
    {:ok, new_struct} ->
      Logger.debug(new_struct)
      new_struct

    {:error, msg} ->
      IO.puts("#{msg}")
      struct
  end
end)
```

## Erlang's "gen_statem" module

We will use the [:gen_statem](https://www.erlang.org/doc/man/gen_statem.html) module (from `Erlang`). It is a `GenServer` like behaviour so is designed for event-driven automatas..

Two callback modes are supported:

* **state functions**: each state (only atoms) is a callback function
* **handle_event_functions**. There is one callback function for all states.

You declare the `callback_mode` choosed in your module. In our case,`handle_events_functions`.

Instead of using `:gen_statem`, we will use the Elixxir librabry `GenStateMachine`. The client function is:

<!-- livebook:{"force_markdown":true} -->

```elixir
:gen_statem.call(pid, :event) <=> GenStateMachine.Call(pid, :event)
```

The callbacks are `handle_event`. They _pattern match_ on an event and a state and return the next possible state. The generic `handle_call` is:

<!-- livebook:{"force_markdown":true} -->

```elixir
handle_event({:call, from}, :event, :current_state, data)
```

It returns the next possible state. Note that you **must** reply as it a synchronous call.

<!-- livebook:{"force_markdown":true} -->

```elixir
 {:next_state, :next_possible_state, data, [{:reply, from, {:ok, :next_possible_state, data}}]}
```

> Note that we can run side-effects, and add messages in the returned tuple. In our case, we count the number of times the door has been opened, and return the count.

> Since we use `.call`, all actions must exit before the callback returns. If we run an `Task.async` (as a demo), it must run to completion so we can call it indirectly. This is normal since we want the operation to be atomic.

```elixir
defmodule GSDoor do
  # @behaviour GSm
  use GenStateMachine, callback_mode: :handle_event_function
  alias GenStateMachine, as: GSm

  def start, do: GSm.start(__MODULE__, :ok, [])
  def init(_), do: {:ok, :locked, 0}

  def terminate(reason, _state, _data),
    do: IO.inspect(" :door terminated with reason - #{reason}")

  def handle_event({:call, from}, :unlock, :locked, data) do
    Task.async(&call_guard/0) |> Task.await()
    {:next_state, :unlocked, data, [{:reply, from, {:ok, :unlocked}}]}
  end

  def handle_event({:call, from}, :lock, :unlocked, data) do
    {:next_state, :locked, data, [{:reply, from, {:ok, :locked}}]}
  end

  def handle_event({:call, from}, :open, :unlocked, data) do
    data = data + 1
    {:next_state, :opened, data, [{:reply, from, {:ok, :opened, data}}]}
  end

  def handle_event({:call, from}, :close, :opened, data) do
    {:next_state, :unlocked, data, [{:reply, from, {:ok, :unlocked}}]}
  end

  def handle_event({:call, from}, _event, _content, data) do
    {:keep_state, data, [{:reply, from, {:error, :invalid_transition}}]}
  end

  def call_guard do
    Task.async(fn ->
      Process.sleep(2_000)
      IO.puts("warn the guards___")
    end)
  end
end
```

```elixir
{:ok, pid} = GSDoor.start()
GenStateMachine.call(pid, :unlock)
```

```elixir
{:ok, pid} = GSDoor.start()
alias GenStateMachine, as: GSm

[:unlock, :close, :open, :open, :close, :open, :close, :lock, :unlock, :open]
|> Enum.map(fn event ->
  :sys.get_state(pid) |> IO.inspect(label: :check_state)
  GSm.call(pid, event)
end)
```

## Time base example: Inactive user

We want some pages to be accessible only to logged-in users. For safety, we also want to log them out after four minutes of inactivity. The UX designer asks to show a warning one minute before logging out to inform the user.

This is a deterministic event-driven process where we have ot consider timers:

```mermaid
  stateDiagram-v2
  direction LR

  idle --> logged_out: 1_min_inactivity
  logged_out --> logged_in: login
  logged_in --> idle: 3_min_inactivity
  idle --> logged_in: activate
```

<!-- livebook:{"break_markdown":true} -->

We can use the previous pattern with a struct in a simple module. To run it continuously, we would need to run it in a `Task` and loop. One problem with this approach is that we cannot communicate with this process. We would need to use a Genserver.

<!-- livebook:{"break_markdown":true} -->

We can also use Erlangs' module `:gen_statem`, more precisely use the package [GenStateMachine](https://hexdocs.pm/gen_state_machine/GenStateMachine.html#module-example) to implement this since we can implement actions as "timeouts" ([see event-timeouts](https://www.erlang.org/doc/man/gen_statem.html#type-event_timeout)). There is no need to set-up your own timers or counters. You add to the callback response the optional action `{timeout, time(ms), :identifier}`. It will be pattern matched by a `handle_event(:timeout, :identifier, state, data)` callback. The `event-timeout` is choosen because any event that arrives cancels this time-out. When a user logs-in, we have a state transition on the event, and we let the callback return the event-timeout action. The timer goes on while no other event cancels it. It will end with a state transition, from "logged-in" to "idle". Any activity will cancel the timer. The "login" state can be hold as long as the session is not "idle". The transition to the "idle" state is monitored by the module and the messages can be captured in a `handle_event(:info?..)`. This callback will return another `event-timeout`, now targetting the `logged_out` state. We can easily insert push-notifications to alert the user.

```elixir
defmodule Inactive do
  use GenStateMachine, callback_mode: :handle_event_function
  alias GenStateMachine, as: GSm

  require Logger
  @timer1 10_000
  @timer2 10_000

  def start(name: user), do: GSm.start(__MODULE__, user, [:debug])
  def init(user), do: {:ok, :logged_out, %{name: user, state: :logged_out, pid: nil}}

  def terminate(reason, _state, _data) do
    push_notification("Your session has expired  due to inactivity")
    Logger.debug(" :inactive terminated with reason - #{inspect(reason)}")
  end

  # login handler triggers first timeout countdown
  def handle_event({:call, from}, :login, :logged_out, data) do
    {pid, _} = from
    Logger.debug("--- Logged in ---")
    data = %{data | state: :logged_in, pid: pid}

    {:next_state, :logged_in, data,
     [{:reply, from, :logged_in}, {:timeout, @timer1, :first_timeout}]}
  end

  # activate session from any moment, transitions to :logged_in
  def handle_event({:call, from}, :activate, _, data) do
    data = %{data | state: :logged_in}
    push_notification(":-- Reset session timers")

    {:next_state, :logged_in, data,
     [{:reply, from, :renewed_session}, {:timeout, @timer1, :first_timeout}]}
  end

  # first notification when state transitions to :idle
  def handle_event(:timeout, :first_timeout, :logged_in, data) do
    push_notification(
      "-- Dear #{data.name}, your session will expire in one minute due to inactivity"
    )

    data = %{data | state: :idle}
    {:next_state, :idle, data}
  end

  # handler to push notification and send signal :shutdown after second timeout
  def handle_event(:timeout, :second_timeout, :idle, _data) do
    Logger.info(":-- Session expired")
    {:stop, :shutdown, :normal}
  end

  # when session activated after transition to :idle
  def handle_event(:timeout, :second_timeout, :logged_in, data) do
    {:next_state, :logged_in, data, [{:timeout, @timer1, :first_timeout}]}
  end

  # catch messages
  def handle_event(:info, {_ref, :ok}, _, data) do
    {:keep_state, data}
  end

  def handle_event(:info, {:DOWN, _, _, _, :normal} = _msg, status, data) do
    {:next_state, status, data, [{:timeout, @timer2, :second_timeout}]}
  end

  # push notifier
  def push_notification(message) do
    Task.async(fn -> Logger.info("#{inspect(message)}") end)
  end
end
```

A user logs into the app and then stays idle. We watch what is happening.

```elixir
{:ok, pid} = Inactive.start(name: "John")
alias GenStateMachine, as: GS
GS.call(pid, :login)
```

```elixir
{:ok, pid} = Inactive.start(name: "John")
alias GenStateMachine, as: GSm
GSm.call(pid, :login)

spawn(fn ->
  for _ <- 1..5 do
    if Process.alive?(pid) do
      GSm.call(pid, :activate)
      (Enum.random(5..25) * 1000) |> Process.sleep()
    end
  end
end)
```

## NFA: Regex example

[Source](https://www.freecodecamp.org/news/state-machines-basics-of-computer-science-d42855debc66/)

This is the most commun type of machines to represent how "real world" systems are working, such as IOT, robots...

An **NFA** or "Non deterministic Finite Automata" is a machine designed to be able to filter a set of reponses, ending with an acceptable state or not. With NF machines, some states can have _multiple next states_ for the _same_ input.

Every DFA is an NFA, but not all NFAs are DFAs. The good news is that every NFA can be _converted to_ a DFA. End of the game? Not really, it is complicated to do so, unless the case is simple :)

The most commun examples of NFA are when using string analysis like **regex**. Given an acceptance criteria, we are looking for which strings are accepted or not by our machine.

Let's say we want to build a finite state machine that can recognize any strings of letters from the set `Q = {"a","b","c","d"}` that:

* starts with "a"
* can have zero or many "b" and "c"
* finishes with the next letter.

The accepted strings ca be for example, "abbbc", "accd", "abc", "ad". The equivalent regex is `~r/(a(c*d))|(a(b*c))/`:

<!-- livebook:{"force_markdown":true} -->

```elixir
string |> String.match?(string, ~r/(a(c*d))|(a(b*c))/)
```

You can test the regex with <https://elixirstream.dev/regex>:

We have a NFA because we have multiple outputs under `c` for the state `M`:

<!-- livebook:{"break_markdown":true} -->

```mermaid
stateDiagram-v2
direction LR
[*]--> M1: a
M1 --> M1: b
M1 --> [*]: c
[*]-->M2: a
M2-->M2: c
M2-->[*]: d
```

The transition table of the NFA is:

|     | a     | b   | c   | d   |
| --- | ----- | --- | --- | --- |
| I   | M1,M2 | x   | x   | x   |
| M1  | x     | M1  | D   |     |
| M2. | x     | x.  | M2  | D   |
| D   | x     | x   | x   | D   |

<!-- livebook:{"break_markdown":true} -->

The transition table converted into a DFA takes into account that a state can only have one next state. If there are several, you combine them into a new one. Here, we combine M1 and M2 into a new state, M12. Then we evaluate where goes M12 under an input and take the union of the states.

|     | a   | b   | c   | d   |
| --- | --- | --- | --- | --- |
| I   | M12 | x   | x   | x   |
| M12 | x.  | M1  | M2D | D   |
| M2D | x.  | x.  | M2  | D.  |
| M1  | x   | M1  | D   | x   |
| M2. | x.  | x.  | M2  | D.  |
| D   | x   | x   | x   | D   |

<!-- livebook:{"break_markdown":true} -->

The corresponding DFA of our machine is:

```mermaid
stateDiagram-v2
direction LR
  [*]-->M12: a
  M12-->M1: b
  M12-->M2D: c
  M12-->[*]: d
  M2D-->M2: c
  M2D-->[*]: d
  M1-->M1: b
  M1-->[*]: c
  M2-->M2: c
  M2-->[*]: d
```

You observe of course an increase in the number of states.

<!-- livebook:{"break_markdown":true} -->

We can code this with `:gen_statem` where we use atoms.

<!-- livebook:{"force_markdown":true} -->

```elixir
{event, state} -> new_state
{:a, :i}-> :m12
{:c, :m12} -> :m2d
{:b, :m12} -> :m1
{:d, :m12} -> :d
{:c, :m2d} -> :m2
{:d, :m2d} -> :d
{:c, :m2} -> :m2
{:d, :m2} -> :d
{:b, :m1}-> :m1
{:c, :m1} -> :d
```

```elixir
defmodule DFA do
  @behaviour :gen_statem

  def start do
    :gen_statem.start(__MODULE__, :ok, [])
  end

  @impl :gen_statem
  def init(_), do: {:ok, :i, nil}

  @impl :gen_statem
  def terminate(reason, _state, _data),
    do: IO.inspect(" :door terminated with reason - #{reason}")

  @impl :gen_statem
  def callback_mode, do: :handle_event_function

  @impl :gen_statem
  def handle_event({:call, from}, :a, :i, _) do
    data = "a"
    {:next_state, :m12, data, [{:reply, from, {:continue, data}}]}
  end

  def handle_event({:call, from}, :b, :m12, data) do
    data = data <> "b"
    {:next_state, :m1, data, [{:reply, from, {:continue, data}}]}
  end

  def handle_event({:call, from}, :c, :m12, data) do
    data = data <> "c"
    {:next_state, :m2d, data, [{:reply, from, {:ok, data}}]}
  end

  def handle_event({:call, from}, :d, :m12, data) do
    data = data <> "d"
    {:next_state, :d, data, [{:reply, from, {:ok, data}}]}
  end

  def handle_event({:call, from}, :c, :m2d, data) do
    data = data <> "c"
    {:next_state, :m2d, data, [{:reply, from, {:continue, data}}]}
  end

  def handle_event({:call, from}, :d, :m2d, data) do
    data = data <> "d"
    {:next_state, :d, data, [{:reply, from, {:ok, data}}]}
  end

  def handle_event({:call, from}, :c, :m2, data) do
    data = data <> "c"
    {:next_state, :m2, data, [{:reply, from, {:continue, data}}]}
  end

  def handle_event({:call, from}, :d, :m2, data) do
    data = data <> "d"
    {:next_state, :d, data, [{:reply, from, {:ok, data}}]}
  end

  def handle_event({:call, from}, :b, :m1, data) do
    data = data <> "b"
    {:next_state, :m1, data, [{:reply, from, {:continue, data}}]}
  end

  def handle_event({:call, from}, :c, :m1, data) do
    data = data <> "c"
    {:next_state, :d, data, [{:reply, from, {:ok, data}}]}
  end

  def handle_event({:call, from}, _event, _content, data) do
    {:keep_state, data, [{:reply, from, {:error, :invalid_transition}}]}
  end
end
```

Let's test if we have build the regex `~r/(a(c*d))|(a(b*c))/)`:

```elixir
s1 = [:a, :c, :b, :b, :c, :e, :c, :d, :f]
s2 = [:a, :f, :b, :b, :c, :e, :c, :d, :f]
s3 = [:a, :c, :b, :c, :d, :d, :d]
s4 = [:a, :b, :b, :d]

defmodule Test do
  alias :gen_statem, as: GS

  def run(s) do
    {:ok, pid} = DFA.start()

    Enum.reduce(s, "", fn letter, acc ->
      case GS.call(pid, letter) do
        {:continue, string} -> {:partial_match, string}
        {:ok, string} -> {:match, string}
        {:error, _} -> acc
      end
    end)
  end
end

{
  Test.run(s1),
  Test.run(s2),
  Test.run(s3),
  Test.run(s4)
}
```

## Testing

To be continued...

```elixir
ExUnit.start(auto_run: false)

defmodule DoorTest do
  use ExUnit.Case, async: false
  import ExUnit.CaptureIO

  doctest Door

  describe "test Machniery module" do
    test "struct" do
      assert %MachineryDoor{} == %{__struct__: MachnieryDoor, count: 0, door: "locked"}
    end

    test "init" do
      result = Machinery.transition_to(%MachineryDoor{}, MachineryDoor, "unlocked")
      IO.inspect(result)
      assert {:ok, %{__struct__: MachineryDoor, count: 0, door: "opened"}} == result
    end

    test "sequence" do
      sequence = [
        "unlocked",
        "closed",
        "opened",
        "opened",
        "unlocked",
        "opened",
        "unlocked",
        "locked",
        "unlocked",
        "opened"
      ]

      result =
        Enum.reduce(sequence, %MachineryDoor{}, fn state, struct ->
          case Machinery.transition_to(struct, MachineryDoor, state) do
            {:ok, new_struct} ->
              IO.inspect(new_struct.door)
              new_struct

            {:error, msg} ->
              IO.puts("#{msg}")
              struct
          end
        end)

      assert {:ok, %{__struct__: MachineryDoor, count: 3, door: "opened"}} == result
    end
  end

  describe "test Door module" do
    test "test initial struct" do
      assert %Door{}.name == nil
      assert %Door{}.state == :unlocked
    end

    test "test steps" do
      door = %Door{name: "home", state: :unlocked}
      {:ok, door} = Door.transition_to(door, :open)

      assert door.state == :opened
      assert door.name == "home"

      {:ok, door} = Door.transition_to(door, :close)

      assert door.state == :unlocked
      assert door.name == "home"

      {:ok, door} = Door.transition_to(door, :open)
      assert door.state == :opened
      assert door.count == 1
    end

    test "assert error" do
      {status, message} = Door.transition_to(%Door{}, :open)
      assert status == :error
      assert message == :invalid_transition
    end

    test "async IO.puts" do
      exec = fn -> Door.call_guard() end
      assert capture_io(exec) =~ "warn the guards"
    end
  end
end
```
